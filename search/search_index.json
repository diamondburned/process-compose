{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Process Compose \ud83d\udd25","text":"<p>Process Compose is a simple and flexible scheduler and orchestrator to manage non-containerized applications.</p>"},{"location":"#why-was-it-made","title":"Why was it made?","text":"<p>Because sometimes you just don't want to deal with docker files, volume definitions, networks and docker registries. Since it's written in Go, Process Compose is a single binary file and has no other dependencies.</p> <p>Once installed, you just need to describe your workflow using a simple YAML schema in a file called <code>process-compose.yaml</code>:</p> <pre><code>version: \"0.5\"\n\nprocesses:\n  hello:\n    command: echo 'Hello World from Process Compose'\n</code></pre> <p>And start it by running <code>process-compose up</code> from your terminal.</p> <p>Check the Documentation for more advanced use cases.</p> <p></p>"},{"location":"#features","title":"Features","text":"<ul> <li>Processes execution (in parallel or/and serially)</li> <li>Processes dependencies and startup order</li> <li>Process recovery policies</li> <li>Manual process [re]start</li> <li>Processes arguments <code>bash</code> or <code>zsh</code> style (or define your own shell)</li> <li>Per process and global environment variables</li> <li>Per process or global (single file) logs</li> <li>Health checks (liveness and readiness)</li> <li>Terminal User Interface (TUI) or CLI modes</li> <li>Forking (services or daemons) processes</li> <li>REST API (OpenAPI a.k.a Swagger)</li> <li>Logs caching</li> <li>Functions as both server and client</li> <li>Configurable shortcuts</li> <li>Merge Configuration Files</li> <li>Namespaces</li> <li>Run Multiple Replicas of a Process</li> <li>Run a Foreground Process </li> <li>Themes Support</li> </ul>"},{"location":"client/","title":"Remote Client","text":""},{"location":"client/#rest-api","title":"REST API","text":"<p>Open API client and documentation is available on: http://localhost:8080</p> <p>Default port is <code>8080</code>. Specify your own port:</p> <pre><code>process-compose -p 8080\n</code></pre> <p>Alternatively use <code>PC_PORT_NUM</code> environment variable:</p> <pre><code>PC_PORT_NUM=8080 process-compose\n</code></pre>"},{"location":"client/#unix-domain-sockets-uds","title":"Unix Domain Sockets (UDS)","text":"<p>Instead of TCP communication mode, on *nix based systems, you can use Unix Domain Sockets (on the same host only).</p> <p>There are 3 configuration options:</p> <ol> <li>Auto socket path based on <code>PID</code>: <code>process-compose -U</code> will start Process Compose in UDS mode and create a socket file under <code>&lt;TempDir&gt;/process-compose-&lt;pid&gt;.sock</code></li> <li>Manual socket path with CLI flag: <code>process-compose --unix-socket /path/to/socket/file</code> will start Process Compose in UDS mode and create the specified socket file. The directory should exist.</li> <li>Manual socket path with environment variable: <code>PC_SOCKET_PATH=\"/path/to/socket/file\" process-compose</code> will start Process Compose in UDS mode and create the specified socket file. The directory should exist.</li> </ol>"},{"location":"client/#client-mode","title":"Client Mode","text":"<p>Process compose can also connect to itself as a client. Available commands:</p>"},{"location":"client/#processes-list","title":"Processes List","text":"<pre><code>process-compose process list #lists available processes\n</code></pre>"},{"location":"client/#process-start","title":"Process Start","text":"<pre><code>process-compose process start [PROCESS] #starts one of the available non running processes\n</code></pre>"},{"location":"client/#process-stop","title":"Process Stop","text":"<pre><code>process-compose process stop [PROCESS] #stops one of the running processes\n</code></pre>"},{"location":"client/#process-restart","title":"Process Restart","text":"<pre><code>process-compose process restart [PROCESS] #restarts one of the available processes\n</code></pre> <p>Restart will wait <code>process.availability.backoff_seconds</code> seconds between <code>stop</code> and <code>start</code> of the process. If not configured the default value is 1s.</p> <p> New remote commands are added constantly. For full list run: <pre><code>process-compose --help\n</code></pre></p> <p>By default, the client will try to use the default port <code>8080</code> and default address <code>localhost</code> to connect to the locally running instance of process-compose. You can provide deferent values:</p> <pre><code>process-compose -p PORT process -a ADDRESS list\n</code></pre>"},{"location":"client/#tui-client","title":"TUI Client","text":"<p>For situations when process-compose was started in headless mode <code>-t=false</code>, another process-compose instance (client) can run in a fully remote TUI mode:</p> <pre><code>process-compose attach\n</code></pre> <p>The client can connect to a:</p> <ul> <li>Remote server</li> <li>Docker container</li> <li>Headless and TUI process-compose instances</li> </ul> <p>In remote mode the Process Compose logo will be replaced from \ud83d\udd25 to \u26a1and show a remote server <code>hostname</code> instead of a local <code>hostname</code>.</p>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#environment-variables","title":"Environment Variables","text":""},{"location":"configuration/#local-per-process","title":"Local (Per Process)","text":"<pre><code>processes:\n  process2:\n    environment:\n      - \"I_AM_LOCAL_EV=42\"\n</code></pre>"},{"location":"configuration/#global","title":"Global","text":"<pre><code>environment:\n  - \"I_AM_GLOBAL_EV=42\"\n\nprocesses:\n  process2:\n    command: \"chmod 666 /path/to/file\"\n  environment:\n    - \"I_AM_LOCAL_EV=42\"\n</code></pre> <p>Default environment variables:</p> <p><code>PC_PROC_NAME</code> - Defines the process name as defined in the <code>process-compose.yaml</code> file.</p> <p><code>PC_REPLICA_NUM</code> - Defines the process replica number. Useful for port collision avoidance for processes with multiple replicas.</p>"},{"location":"configuration/#env-file","title":".env file","text":"<p><pre><code>VERSION='1.2.3'\nDB_USER='USERNAME'\nDB_PASSWORD='VERY_STRONG_PASSWORD'\nWAIT_SEC=60\n</code></pre> Override ${var} and $var from environment variables or .env values <pre><code>processes:\n  downloader:\n    command: \"python3 data_downloader_${VERSION}.py -s 'data.source.B.uri'\"\n    availability:\n      restart: \"always\"\n      backoff_seconds: ${WAIT_SEC}\n    environment:\n      - 'OUTPUT_DIR=/path/to/B/data'\n</code></pre></p>"},{"location":"configuration/#variables","title":"Variables","text":"<p>Variables in Process Compose rely on Go template engine</p>"},{"location":"configuration/#rendered-parameters","title":"Rendered Parameters:","text":"<ul> <li><code>processes.process.command</code></li> <li><code>processes.process.working_dir</code></li> <li><code>processes.process.log_location</code></li> <li><code>processes.process.description</code></li> <li>For <code>readiness_probe</code>and <code>liveness_probe</code>:</li> <li><code>processes.process.&lt;probe&gt;.exec.command</code></li> <li><code>processes.process.&lt;probe&gt;.http_get.host</code></li> <li><code>processes.process.&lt;probe&gt;.http_get.path</code></li> <li><code>processes.process.&lt;probe&gt;.http_get.scheme</code></li> </ul>"},{"location":"configuration/#local-per-process_1","title":"Local (Per Process)","text":"<pre><code>processes:\n  watcher:\n    vars:\n      LOG_LOCATION: \"./watcher.log\"\n      OK: SUCCESS\n      PRE: 2\n      POST: 8\n\n    command: \"sleep {{.PRE}} &amp;&amp; echo {{.OK}} &amp;&amp; sleep {{.POST}}\"\n    log_location: {{.LOG_LOCATION}}\n    readiness_probe:\n      exec:\n        command: \"grep -q {{.OK}} {{.LOG_LOCATION}}\"\n      initial_delay_seconds: 1\n      period_seconds: 1\n      timeout_seconds: 1\n      success_threshold: 1      \n</code></pre> <p> Notice the <code>.</code> (dot) before each <code>.VARIABLE</code></p>"},{"location":"configuration/#global_1","title":"Global","text":"<p><pre><code>vars:\n  VERSION: v1.2.3\n  FTR_A_ENABLED: true\n  FTR_B_ENABLED: true\n\nprocesses:\n  version:\n    # Environment and Process Compose variables can complement each other\n    command: \"echo 'version {{or \\\"${VERSION}\\\" .VERSION}}'\"\n  feature:\n    command: \"echo '{{if .FTR_A_ENABLED}}Feature A Enabled{{else}}Feature A Disalbed{{end}}'\"\n  not_supported:\n    command: \"echo 'Hi {{if and .FTR_A_ENABLED .FTR_B_ENABLED}}Not Supported{{end}}'\"\n</code></pre> <pre><code>#output:\nversion v1.2.3 #if $VERSION environment variable is undefined. The value of $VERSION if it is. \nFeature A Enabled\nNot Supported\n</code></pre></p>"},{"location":"configuration/#template-escaping","title":"Template Escaping","text":"<p>In a scenario where Go template syntax is part of your command, you will want to escape it:</p> <pre><code>{{ \"{{ .SOME_VAR }}\" }}\n</code></pre> <p>For example:</p> <pre><code>processes:\n  nginx:\n    command: \"docker run -d --rm -p80:80 --name nginx_test nginx\"\n    liveness_probe:\n      exec:\n        command: '[ $(docker inspect -f \"{{.State.Running}}\" nginx_test) = true ]'\n</code></pre> <p>Will become:</p> <pre><code>processes:\n  nginx:\n    command: \"docker run -d --rm -p80:80 --name nginx_test nginx\"\n    liveness_probe:\n      exec:\n        command: '[ $(docker inspect -f {{ \"{{.State.Running}}\" }} nginx_test) = true ]'\n</code></pre> <p> For backward compatibility, if neither global nor local variables exist in <code>process-compose.yaml</code> the template engine won't run.</p>"},{"location":"configuration/#specify-which-configuration-files-to-use","title":"Specify which configuration files to use","text":"<pre><code>process-compose -f \"path/to/process-compose-file.yaml\"\n</code></pre>"},{"location":"configuration/#auto-discover-configuration-files","title":"Auto discover configuration files","text":"<p>The following discovery order is used: <code>compose.yml, compose.yaml, process-compose.yml, process-compose.yaml</code>. If multiple files are present the first one will be used.</p>"},{"location":"configuration/#merge-2-or-more-configuration-files-with-override-values","title":"Merge 2 or more configuration files with override values","text":"<pre><code>process-compose -f \"path/to/process-compose-file.yaml\" -f \"path/to/process-compose-override-file.yaml\"\n</code></pre> <p>Using multiple <code>process-compose</code> files lets you customize a <code>process-compose</code> application for different environments or different workflows.</p> <p>See the Merging Configuration for more information on merging files.</p>"},{"location":"configuration/#backend","title":"Backend","text":"<p>For cases where your process compose requires a non default or transferable backend definition, setting an environment variable won't do. For that, you can configure it directly in the <code>process-compose.yaml</code> file:</p> <pre><code>version: \"0.5\"\nshell:\n  shell_command: \"python3\"\n  shell_argument: \"-m\"\nprocesses:\n  http:\n    command: \"server.py\"\n</code></pre> <p>Note: please make sure that the <code>shell.shell_command</code> value is in your <code>$PATH</code></p>"},{"location":"configuration/#linux","title":"Linux","text":"<p>The default backend is <code>bash</code>. You can define a different backend with a <code>COMPOSE_SHELL</code> environment variable.</p>"},{"location":"configuration/#windows","title":"Windows","text":"<p>The default backend is <code>cmd</code>. You can define a different backend with a <code>COMPOSE_SHELL</code> environment variable.</p> <pre><code>process1:\n  command: \"python -c print(str(40+2))\"\n  #note that the same command for bash/zsh would look like: \"python -c 'print(str(40+2))'\"\n</code></pre> <p>Using <code>powershell</code> backend had some funky behavior (like missing <code>command1 &amp;&amp; command2</code> functionality in older versions). If you need to run powershell scripts, use the following syntax:</p> <pre><code>process2:\n  command: \"powershell.exe ./test.ps1 arg1 arg2 argN\"\n</code></pre>"},{"location":"configuration/#macos","title":"macOS","text":"<p>The default backend is <code>bash</code>. You can define a different backend with a <code>COMPOSE_SHELL</code> environment variable.</p>"},{"location":"configuration/#namespaces","title":"Namespaces","text":"<p>Assigning namespaces to processes allows better grouping and sorting, especially in TUI:</p> <pre><code>processes:\n  process1:\n    command: \"tail -f -n100 process-compose-${USER}.log\"\n    working_dir: \"/tmp\"\n    namespace: debug # if not defined 'default' namespace is automatically assigned to each process\n</code></pre> <p>Note: By default <code>process-compose</code> will start process from all the configured namespaces. To start a sub set of the configured namespaces (<code>ns1</code>, <code>ns2</code>, <code>ns3</code>):</p> <pre><code>process-compose -n ns1 -n ns3\n# will start only ns1 and ns3. ns2 namespace won't run and won't be visible in the TUI\n</code></pre>"},{"location":"configuration/#misc","title":"Misc","text":""},{"location":"configuration/#strict-configuration-validation","title":"Strict Configuration Validation","text":"<p>To avoid minor <code>proces-compose.yaml</code> configuration errors and typos it is recommended to enable <code>is_strict</code> flag:</p> <p><pre><code>version: \"0.5\"\nis_strict: true\nprocesses:\n  process1:\n   commnad: \"sleep 1\" # &lt;-- notice the typo here\n</code></pre> The above configuration will fail the Process Compose start and exit with error code <code>1</code>: <pre><code>unknown key commnad found in process process1\n</code></pre></p>"},{"location":"configuration/#pseudo-terminals","title":"Pseudo Terminals","text":"<p>Certain processes check if they are running within a terminal, to simulate a TTY mode you can use a <code>is_tty</code> flag:</p> <pre><code>processes:  \n  process0:\n    command: \"ls -lFa --color=tty\"\n    is_tty: true\n</code></pre> <p> <code>STDIN</code> and <code>Windows</code> are not supported at this time.</p>"},{"location":"configuration/#multiline-command-support","title":"Multiline Command Support","text":"<p>Process Compose respects all the multiline <code>YAML</code> specification variations. </p> <p>Examples:</p> <pre><code>processes:\n  block_folded:\n    command: &gt;\n      echo 1\n      &amp;&amp; echo 2\n\n      echo 3\n\n  block_literal:\n    command: |\n      echo 4\n      echo 5\n    depends_on:\n      block_folded:\n        condition: process_completed\n\n  flow_single:\n    command: 'echo 6\n      &amp;&amp; echo 7\n\n      echo 8'\n    depends_on:\n      block_literal:\n        condition: process_completed\n\n  flow_double:\n    command: \"echo 9\n      &amp;&amp; echo 10\n\n      echo 11\"\n    depends_on:\n      flow_single:\n        condition: process_completed\n\n  flow_plain:\n    command: echo 12\n      &amp;&amp; echo 13\n\n      echo 14\n    depends_on:\n      flow_double:\n        condition: process_completed\n</code></pre> <p> The extra blank lines (<code>\\n</code>) in the command string are to introduce a newline to the command.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#set-up-your-machine","title":"Set up your machine","text":"<p>Process Compose is written in Go.</p>"},{"location":"contributing/#prerequisites","title":"Prerequisites:","text":"<ul> <li>Make</li> <li>Go 1.21+</li> </ul>"},{"location":"health/","title":"Health Checks","text":"<p>Many applications running for long periods of time eventually transition to broken states, and cannot recover except by being restarted. Process Compose provides liveness and readiness probes to detect and remedy such situations.</p> <p>Probes configuration and functionality are designed to work similarly to Kubernetes liveness and readiness probes.</p>"},{"location":"health/#liveness-probe","title":"Liveness Probe","text":"<pre><code>processes:\n  nginx:\n    command: \"docker run -d --rm -p80:80 --name nginx_test nginx\"\n    is_daemon: true\n    shutdown:\n      command: \"docker stop nginx_test\"\n      signal: 15\n      timeout_seconds: 5\n    liveness_probe:\n      exec:\n        command: \"[ $(docker inspect -f '{{.State.Running}}' nginx_test) = 'true' ]\"\n        working_dir: /tmp # if not specified the process working dir will be used\n      initial_delay_seconds: 5\n      period_seconds: 2\n      timeout_seconds: 5\n      success_threshold: 1\n      failure_threshold: 3\n</code></pre>"},{"location":"health/#readiness-probe","title":"Readiness Probe","text":"<pre><code>processes:\n  nginx:\n    command: \"docker run -d --rm -p80:80 --name nginx_test nginx\"\n    is_daemon: true\n    shutdown:\n      command: \"docker stop nginx_test\"\n    readiness_probe:\n      http_get:\n        host: 127.0.0.1\n        scheme: http\n        path: \"/\"\n        port: 80\n      initial_delay_seconds: 5\n      period_seconds: 10\n      timeout_seconds: 5\n      success_threshold: 1\n      failure_threshold: 3\n</code></pre> <p>Each probe type (<code>liveness_probe</code> or <code>readiness_probe</code>) can be configured to use one of the 2 mutually exclusive modes:</p> <ol> <li><code>exec</code>: Will run a configured <code>command</code> and based on the <code>exit code</code> decide if the process is in a correct state. 0 indicates success. Any other value indicates failure.</li> <li><code>http_get</code>: For an HTTP probe, the Process Compose sends an HTTP request to the specified path and port to perform the check. Response code 200 indicates success. Any other value indicates failure.</li> <li><code>host</code>: Host name to connect to.</li> <li><code>scheme</code>: Scheme to use for connecting to the host (HTTP or HTTPS). Defaults to HTTP.</li> <li><code>path</code>: Path to access on the HTTP server. Defaults to /.</li> <li><code>port</code>: Number of port to access the process. The number must be in the range 1 to 65535.</li> </ol>"},{"location":"health/#configure-probes","title":"Configure Probes","text":"<p>Probes have a number of fields that you can use to control the behavior of liveness and readiness checks more precisely:</p> <ul> <li><code>initial_delay_seconds</code>: Number of seconds after the container has started before liveness or readiness probes are initiated. Defaults to 0 seconds. The minimum value is 0.</li> <li><code>period_seconds</code>: How often (in seconds) to perform the probe. Defaults to 10 seconds. The minimum value is 1.</li> <li><code>timeout_seconds</code>: Number of seconds after which the probe times out. Defaults to 1 second. The minimum value is 1.</li> <li><code>success_threshold</code>: Minimum consecutive successes for the probe to be considered successful after failing. Defaults to 1. Must be 1 for liveness and startup Probes. The minimum value is 1. Note: this value is not respected and was added as a placeholder for future implementation.</li> <li><code>failure_threshold</code>: When a probe fails, Process Compose will try <code>failure_threshold</code> times before giving up. Giving up in case of readiness probe means restarting the process. In case of liveness probe and <code>is_daemon</code> set to <code>true</code> the daemon will be considered stopped. Process Compose will follow the availability configuration to decide if restart is needed.  Defaults to 3. The minimum value is 1.</li> </ul>"},{"location":"health/#auto-restart-if-not-healthy","title":"Auto Restart if not Healthy","text":"<p>In order to ensure that the process is restarted (and not transitioned to a completed state) in case of readiness check fail, please make sure to define the <code>availability</code> configuration. For background (<code>is_daemon=true</code>) processes, the <code>restart</code> policy should be <code>always</code>.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#download-the-binary","title":"Download the Binary","text":""},{"location":"installation/#binary","title":"Binary","text":"<p>Go to the releases, download the package for your OS, and add to your <code>$PATH</code>.</p>"},{"location":"installation/#install-script","title":"Install Script","text":"<p>Install script which is very useful in scenarios like CI. Many thanks to GoDownloader for enabling the easy generation of this script.</p> <p>By default, it installs on the <code>./bin</code> directory relative to the working directory:</p> <pre><code>sh -c \"$(curl --location https://raw.githubusercontent.com/F1bonacc1/process-compose/main/scripts/get-pc.sh)\" -- -d\n</code></pre> <p>It is possible to override the installation directory with the <code>-b</code> parameter. On Linux, common choices are <code>~/.local/bin</code> and <code>~/bin</code> to install for the current user or <code>/usr/local/bin</code> to install for all users:</p> <pre><code>sh -c \"$(curl --location https://raw.githubusercontent.com/F1bonacc1/process-compose/main/scripts/get-pc.sh)\" -- -d -b ~/.local/bin\n</code></pre> <p>Caution</p> <p>On macOS and Windows, <code>~/.local/bin</code> and <code>~/bin</code> are not added to <code>$PATH</code> by default.</p>"},{"location":"installation/#nix","title":"Nix","text":"<p>If you have the Nix package manager installed with Flake support, just run:</p> <pre><code># to use the latest binary release\nnix run nixpkgs/master#process-compose -- --help\n\n# or to compile from the latest source\nnix run github:F1bonacc1/process-compose -- --help\n</code></pre> <p>To use process-compose declaratively configured in your project <code>flake.nix</code>, checkout process-compose-flake.</p>"},{"location":"installation/#brew-macos-and-linux","title":"Brew (MacOS and Linux)","text":"<pre><code>brew install f1bonacc1/tap/process-compose\n</code></pre>"},{"location":"intro/","title":"Getting Started","text":""},{"location":"intro/#quick-start","title":"Quick Start","text":"<p>Imaginary system diagram:</p> <p></p> <p><code>process-compose.yaml</code> definitions for the system above:</p> <pre><code>version: \"0.5\"\n\nenvironment:\n  - \"GLOBAL_ENV_VAR=1\"\nlog_location: /path/to/combined/output/logfile.log\nlog_level: debug\n\nprocesses:\n  Manager:\n    command: \"/path/to/manager\"\n    availability:\n      restart: \"always\"\n    depends_on:\n      ClientA:\n        condition: process_started\n      ClientB:\n        condition: process_started\n\n  ClientA:\n    command: \"/path/to/ClientA\"\n    availability:\n      restart: \"always\"\n    depends_on:\n      Server_1A:\n        condition: process_started\n      Server_2A:\n        condition: process_started\n    environment:\n      - \"LOCAL_ENV_VAR=1\"\n\n  ClientB:\n    command: \"/path/to/ClientB -some -arg\"\n    availability:\n      restart: \"always\"\n    depends_on:\n      Server_1B:\n        condition: process_started\n      Server_2B:\n        condition: process_started\n    environment:\n      - \"LOCAL_ENV_VAR=2\"\n\n  Server_1A:\n    command: \"/path/to/Server_1A\"\n    availability:\n      restart: \"always\"\n\n  Server_2A:\n    command: \"/path/to/Server_2A\"\n    availability:\n      restart: \"always\"\n\n  Server_1B:\n    command: \"/path/to/Server_1B\"\n    availability:\n      restart: \"always\"\n\n  Server_2B:\n    command: \"/path/to/Server_2B\"\n    availability:\n      restart: \"always\"\n</code></pre> <p>Finally, run <code>process-compose</code> in the <code>process-compose.yaml</code> directory. Or give it a direct path:</p> <pre><code>process-compose -f /path/to/process-compose.yaml\n</code></pre>"},{"location":"launcher/","title":"Processes Lifetime","text":""},{"location":"launcher/#start-in-parallel","title":"Start in Parallel","text":"<pre><code>processes:\n  process1:\n    description: This process will sleep for 2 seconds\n    command: \"sleep 3\"\n  process2:\n    description: This process will sleep for 3 seconds\n    command: \"sleep 3\"\n</code></pre> <p> It's recommended to add a process description. It will be shown in the Process Info Dialog (<code>F3</code>) in the TUI.</p>"},{"location":"launcher/#start-serially","title":"Start Serially","text":"<pre><code>processes:\n  process1:\n    command: \"sleep 3\"\n    depends_on:\n      process2:\n        condition: process_completed_successfully # or \"process_completed\" if you don't care about errors\n  process2:\n    command: \"sleep 3\"\n    depends_on:\n      process3:\n        condition: process_completed_successfully # or \"process_completed\" if you don't care about errors\n</code></pre>"},{"location":"launcher/#multiple-replicas-of-a-process","title":"Multiple Replicas of a Process","text":"<p>You can run multiple replicas of a process by adding <code>processes.process_name.replicas</code> parameter (default: 1)</p> <pre><code>processes:\n  process_name:\n    command: \"sleep 2\"\n    log_location: ./log_file.{PC_REPLICA_NUM}.log  # &lt;- {PC_REPLICA_NUM} will be replaced with replica number. If more than one replica and PC_REPLICA_NUM is not specified, the replica number will be concatenated to the file end.\n    replicas: 2\n</code></pre> <p>To scale a process on the fly CLI:</p> <pre><code>process-compose process scale process_name 3\n</code></pre> <p>To scale a process on the fly TUI: <code>F2</code> or Process Compose in client mode (<code>process-compose attach</code>).</p> <p> Starting multiple processes using the same port, will fail. Please use the injected <code>PC_REPLICA_NUM</code> environment variable to increment the used port number.</p>"},{"location":"launcher/#specify-a-working-directory","title":"Specify a working directory","text":"<pre><code>processes:\n  process1:\n    command: \"ls -laF --color=always\"\n    working_dir: \"/path/to/your/working/directory\"\n</code></pre> <p>Make sure that you have the proper access permissions to the specified <code>working_dir</code>. If not, the command will fail with a <code>permission denied</code> error. The process status in TUI will be <code>Error</code>.</p>"},{"location":"launcher/#define-process-dependencies","title":"Define process dependencies","text":"<pre><code>processes:\n  process2:\n    depends_on:\n      process3:\n        condition: process_completed_successfully\n      process4:\n        condition: process_completed_successfully\n</code></pre> <p>There are 5 condition types that can be used in process dependencies:</p> <ul> <li><code>process_completed</code> - is the type for waiting until a process has been completed (any exit code)</li> <li><code>process_completed_successfully</code> - is the type for waiting until a process has been completed successfully (exit code 0)</li> <li><code>process_healthy</code> - is the type for waiting until a process is healthy</li> <li><code>process_started</code> - is the type for waiting until a process has started (default)</li> <li><code>process_log_ready</code> - is the type for waiting until a process has printed a predefined log line. This requires the definition of <code>ready_log_line</code> in the dependent process.</li> </ul>"},{"location":"launcher/#process-log-ready-example","title":"Process Log Ready Example","text":"<p>In some situations a process's log output is a simple way to determine if it is ready or not. For example, we can wait for a 'ready' message in the process's logs as follows:</p> <pre><code>processes:\n  world:\n    command: \"echo Connected\"\n    depends_on:\n      hello:\n        condition: process_log_ready\n  hello:\n    command: |\n      echo 'Preparing...'\n      sleep 1\n      echo 'I am ready to accept connections now'\n    ready_log_line: \"ready to accept connections\" # equal to *.ready to accept connections.*\\n regex    \n</code></pre> <p> <code>ready_log_line</code> and readiness probe are incompatible and can't be used at the same time.</p>"},{"location":"launcher/#run-only-specific-processes","title":"Run only specific processes","text":"<p>For testing and debugging purposes, especially when your <code>process-compose.yaml</code> file contains many processes, you might want to specify only a subset of processes to run. For example:</p> <pre><code>#process-compose.yaml\nprocesses:\n  process1:\n    command: \"echo 'Hi from Process1'\"\n    depends_on:\n      process2:\n        condition: process_completed_successfully\n  process2:\n    command: \"echo 'Hi from Process2'\"\n  process3:\n    command: \"echo 'Hi from Process3'\"\n</code></pre> <pre><code>process-compose up # will run all the processes - equal to 'process-compose'\n\n#output:\n#Hi from Process3\n#Hi from Process2\n#Hi from Process1\n</code></pre> <pre><code>process-compose up process1 process3 # will run 'process1', 'process3' and all of their dependencies - 'process2'\n\n#output:\n#Hi from Process3\n#Hi from Process2\n#Hi from Process1\n</code></pre> <pre><code>process-compose up process1 process3 --no-deps # will run 'process1', 'process3' without any dependencies\n\n#output:\n#Hi from Process3\n#Hi from Process1\n</code></pre>"},{"location":"launcher/#termination-parameters","title":"Termination Parameters","text":"<pre><code>processes:\n  nginx:\n    command: \"docker run --rm --name nginx_test nginx\"\n    shutdown:\n      command: \"docker stop nginx_test\"\n      timeout_seconds: 10 # default 10\n      signal: 15 # default 15, but only if the 'command' is not defined or empty\n      parent_only: no  # default no. If yes, only signal the running process instead of its whole process group\n</code></pre> <p><code>shutdown</code> is optional and can be omitted. The default behavior in this case: <code>SIGTERM</code> is issued to the process group of the running process.</p> <p>In case only <code>shutdown.signal</code> is defined <code>[1..31]</code> the running process group will be terminated with its value.</p> <p>If <code>shutdown.parent_only</code> is yes, the signal is only sent to the running process and not to the whole process group.</p> <p>In case the <code>shutdown.command</code> is defined:</p> <ol> <li>The <code>shutdown.command</code> is executed with all the Environment Variables of the primary process</li> <li>Wait for <code>shutdown.timeout_seconds</code> for its completion (if not defined wait for 10 seconds)</li> <li>In case of timeout, the process group will receive the <code>SIGKILL</code> signal (irrespective of the <code>shutdown.parent_only</code> option).</li> </ol>"},{"location":"launcher/#background-detached-processes","title":"Background (detached) Processes","text":"<pre><code>processes:\n  nginx:\n    command: \"docker run -d --rm --name nginx_test nginx\" # note the '-d' for detached mode\n    is_daemon: true # this flag is required for background processes (default false)\n    shutdown:\n      command: \"docker stop nginx_test\"\n      timeout_seconds: 10 # default 10\n      signal: 15 # default 15, but only if command is not defined or empty\n</code></pre> <ol> <li> <p>For processes that start services / daemons in the background, please use the <code>is_daemon</code> flag set to <code>true</code>.</p> </li> <li> <p>In case a process is daemon it will be considered running until stopped.</p> </li> <li> <p>Daemon processes can only be stopped with the <code>$PROCESSNAME.shutdown.command</code> as in the example above.</p> </li> </ol>"},{"location":"launcher/#foreground-processes","title":"Foreground Processes","text":"<p><pre><code>processes:\n  vim:\n    command: \"vim process-compose.yaml\"\n    is_foreground: true\n</code></pre> Foreground processes are useful for cases when a full <code>tty</code> access is required (e.g. <code>vim</code>, <code>top</code>, <code>gdb -tui</code>)</p> <ol> <li>Foreground process have to be started manually (<code>F7</code>). They can be started multiple times.</li> <li>They are available in TUI mode only.</li> <li>To return to TUI, exit the foreground process.</li> <li>In TUI Client mode, a local process will be started.</li> </ol>"},{"location":"launcher/#disabled-processes","title":"Disabled Processes","text":"<p>Process execution can be disabled:</p> <pre><code>processes:\n  process_name:\n    command: \"ls -R /\"\n    disabled: true #default false\n</code></pre> <p>Even if disabled, the process is still listed in the TUI and the REST client, and can be started manually when needed.</p>"},{"location":"launcher/#auto-restart-on-exit","title":"Auto Restart on Exit","text":"<pre><code>processes:\n  process2:\n    availability:\n      restart: on_failure # other options: \"exit_on_failure\", \"always\", \"no\" (default)\n      backoff_seconds: 2 # default: 1\n      max_restarts: 5 # default: 0 (unlimited)\n</code></pre>"},{"location":"launcher/#terminate-process-compose-on-failure","title":"Terminate Process Compose on Failure","text":"<p>There are cases when you might want <code>process-compose</code> to terminate immediately when one of the processes exits with a non <code>0</code> exit code. This can be useful when you would like to perform \"pre-flight\" validation checks on the environment.</p> <p>To achieve that, use <code>exit_on_failure</code> restart policy. If defined, <code>process-compose</code> will gracefully shut down all the other running processes and exit with the same exit code as the failed process.</p> <pre><code>processes:\n  sanitycheck:\n    command: \"which go\"\n    availability:\n      restart: \"exit_on_failure\"\n\n  other_proc:\n    command: \"go test ./...\"\n    depends_on:\n      sanitycheck:\n        condition: process_completed_successfuly\n</code></pre>"},{"location":"launcher/#terminate-process-compose-once-given-process-ends","title":"Terminate Process Compose once given process ends","text":"<p>There are cases when you might want <code>process-compose</code> to terminate immediately when one of the processes exits (regardless of the exit code). For example when running tests that depend on other processes like databases etc. You might want the processes, on which the test process depends, to start first, then run the tests, and finally terminate all processes once the test process exits, reporting the code returned by the test process.</p> <p>To achieve that, set <code>availability.exit_on_end</code> to <code>true</code>, and <code>process-compose</code> will gracefully shut down all the other running processes and exit with the same exit code as the given process.</p> <pre><code>processes:\n  tests:\n    command: tests-run\n    availability:\n      # NOTE: `restart: exit_on_failure` is not needed since\n      # exit_on_end implies it.\n      exit_on_end: true\n    depends_on:\n      redis: process_healthy\n      postgres: process_healthy\n\n  redis:\n    command: redis-start\n    readiness_probe:\n      exec:\n        command: redis-health-check\n\n  postgres:\n    command: postgres-start\n    readiness_probe:\n      exec:\n        command: postgres-health-check\n</code></pre> <p> setting <code>restart: exit_on_failure</code> together with <code>exit_on_end: true</code> is not needed as the latter causes termination regardless of the exit code. However, it might be sometimes useful to <code>exit_on_end</code> with <code>restart: on_failure</code> and <code>max_restarts</code> in case you want the process to recover from failure and only cause termination on success.</p> <p> <code>exit_on_end</code> can be set on more than one process, for example when running multiple tasks in parallel and wishing to terminate as soon as any one finished.</p>"},{"location":"logging/","title":"Logger","text":""},{"location":"logging/#per-process-log-collection","title":"Per Process Log Collection","text":"<pre><code>process2:\n  log_location: ./pc.process2.log #if undefined or empty no logs will be saved\n</code></pre> <p>Captures StdOut and StdErr output</p>"},{"location":"logging/#merge-into-a-single-file-unified-logging","title":"Merge into a single file (Unified Logging)","text":"<pre><code>environment:\n  - \"ABC=42\"\nlog_location: ./pc.global.log #if undefined or empty, no logs will be saved (if not defined per process)\nprocesses:\n  process2:\n    command: \"chmod 666 /path/to/file\"\n</code></pre>"},{"location":"logging/#process-compose-console-log-level","title":"Process compose console log level","text":"<pre><code>log_level: info # other options: \"trace\", \"debug\", \"info\", \"warn\", \"error\", \"fatal\", \"panic\"\nprocesses:\n  process2:\n    command: \"chmod 666 /path/to/file\"\n</code></pre> <p>This setting controls the <code>process-compose</code> log level. The processes log level should be defined inside the process. It is recommended to support this definition with an environment variable in <code>process-compose.yaml</code></p>"},{"location":"logging/#log-rotation","title":"Log Rotation","text":"<pre><code># unified log\nversion: \"0.5\"\nlog_level: info \nlog_location: /tmp/pc.log\nlog_configuration:\n  rotation:\n    max_size_mb: 1  # the max size in MB of the logfile before it's rolled\n    max_age_days: 3 # the max age in days to keep a logfile\n    max_backups: 3  # the max number of rolled files to keep\n    compress: true  # determines if the rotated log files should be compressed using gzip. The default is false\n\n#process level logging (same syntax)\nprocesses:\n  someProc:\n    command: \"some command\"\n    log_configuration:\n      rotation:\n        max_size_mb: 1  # the max size in MB of the logfile before it's rolled\n        max_age_days: 3 # the max age in days to keep a logfile\n        max_backups: 3  # the max number of rolled files to keep\n        compress: true  # determines if the rotated log files should be compressed using gzip. The default is false\n</code></pre>"},{"location":"logging/#logger-configuration","title":"Logger Configuration","text":"<pre><code>log_configuration:\n  fields_order: [\"time\", \"level\", \"message\"] # order of logging fields. The default is time, level, message\n  disable_json: true                         # output as plain text. The default is false\n  timestamp_format: \"06-01-02 15:04:05.000\"  # timestamp format. The default is RFC3339\n  no_metadata: true                          # don't log process name and replica number\n  add_timestamp: true                        # add timestamp to the logger. Default is false\n  no_color: true                             # disable ANSII colors in the logger. Default is false\n  flush_each_line: true                      # disable buffering and flush each line to the log file. Default is false\n</code></pre> Parameter Name Description Depends On Default Value <code>fields_order</code> Order of the logging fields. The default is time, level, message. In case one of the fields is omitted, it will be missing in the log as well. <code>disable_json: true</code><code>add_timestamp: true</code> for <code>\"time\"</code> <code>[\"time\", \"level\", \"message\"]</code> <code>disable_json</code> Disables JSON logging format. Use Console Mode Format. <code>false</code> <code>timestamp_format</code> Sets the format of the logger timestamp. <code>add_timestamp: true</code> If <code>disable_json: true</code>:<code>3:04PM</code>If <code>disable_json: false</code>:<code>\"2006-01-02T15:04:05Z07:00\"</code> <code>no_metadata</code> Don't log the process name and replica number. <code>false</code> <code>add_timestamp</code> Add timestamp to the logger. Useful for processes without an internal logger. <code>false</code> <code>no_color</code> Disable ANSII colors in the log file. <code>disable_json: true</code> <code>false</code> <code>flush_each_line</code> Disable buffering and flush each line to the log file. <code>false</code>"},{"location":"logging/#process-compose-internal-log","title":"Process Compose Internal Log","text":"<p>Default log location: <code>/tmp/process-compose-$USER.log</code></p> <p> It is recommended to add the following process configuration to your <code>process-compose.yaml</code>:</p> <pre><code>processes:\n  pc_log:\n    command: \"tail -f -n100 process-compose-${USER}.log\"\n    working_dir: \"/tmp\"\n</code></pre> <p>This will allow you to spot any issues with the processes execution, without leaving the <code>process-compose</code> TUI.</p>"},{"location":"merge/","title":"Merging Configuration","text":"<p>Using multiple <code>process-compose</code> files lets you to customize a <code>process-compose</code> application for different environments or different workflows.</p>"},{"location":"merge/#understanding-multiple-compose-files","title":"Understanding multiple Compose files","text":"<p>By default, <code>process-compose</code> reads two files, a <code>process-compose.yml</code> and an optional <code>process-compose.override.yml</code> file. By convention, the <code>process-compose.yml</code> contains your base configuration. The override file, as its name implies, can contain configuration overrides for existing processes or entirely new processes.</p> <p>If a process is defined in both files, <code>process-compose</code> merges the configurations using the rules described in Adding and overriding configuration.</p> <p>To use multiple override files, or an override file with a different name, you can use the <code>-f</code> option to specify the list of files. <code>process-compose</code> merges files in the order they\u2019re specified on the command line. </p> <p>When you use multiple configuration files, you must make sure all paths in the files are relative to the base <code>process-compose</code> file (the first <code>process-compose</code> file specified with <code>-f</code>). This is required because override files need not be valid <code>process-compose</code> files. Override files can contain small fragments of configuration. Tracking which fragment of a process is relative to which path is difficult and confusing, so to keep paths easier to understand, all paths must be defined relative to the base file.</p>"},{"location":"merge/#example-use-case","title":"Example use case","text":""},{"location":"merge/#different-environments","title":"Different environments","text":"<p>A common use case for multiple files is changing a development <code>process-compose</code> app for a production-like environment (which may be production, staging or CI). To support these differences, you can split your <code>process-compose</code> configuration into a few different files:</p> <p>Start with a base file that defines the canonical configuration for the processes.</p> <p>process-compose.yml</p> <pre><code>processes:\n  web:\n    command: \"npm start\"\n    depends_on:\n      db:\n        condition: process_started\n      cache:\n        condition: process_started\n\n  db:\n    command: \"pg_ctl start -l logfile\"\n\n  cache:\n    command: \"systemctl start redis\"\n</code></pre> <p>In this example the development configuration adds debug flags.</p> <p>process-compose.override.yml</p> <pre><code>processes:\n  web:\n    environment:\n      - \"DEBUG=true\"\n\n  db:\n    command: \"pg_ctl start -l logfile -d\"\n</code></pre> <p>When you run <code>process-compose</code> it reads the overrides automatically.</p> <p>Now, it would be nice to use this <code>process-compose</code> app in a production environment. So, create another override file (which might be stored in a different git repo or managed by a different team).</p> <p>process-compose.prod.yml</p> <pre><code>processes:\n  web:\n    environment:\n      - \"PRODUCTION=true\"\n\n  cache:\n    environment:\n      - \"TTL=500\"\n</code></pre> <p>To deploy with this production <code>process-compose</code> file you can run</p> <pre><code>$ process-compose -f process-compose.yml -f process-compose.prod.yml\n</code></pre> <p>This deploys all three processes using the configuration in <code>process-compose.yml</code> and <code>process-compose.prod.yml</code> (but not the dev configuration in <code>process-compose.override.yml</code>).</p>"},{"location":"merge/#adding-and-overriding-configuration","title":"Adding and overriding configuration","text":"<p><code>process-compose</code> copies configurations from the original process over to the local one. If a configuration option is defined in both the original process and the local process, the local value replaces or extends the original value.</p> <p>For single-value options like <code>command</code>, <code>working_dir</code> or <code>disabled</code>, the new value replaces the old value.</p> <p>original process:</p> <pre><code>processes:\n  myprocess:\n    # ...\n    command: python app.py\n</code></pre> <p>local process:</p> <pre><code>processes:\n  myprocess:\n    # ...\n    command: python otherapp.py\n</code></pre> <p>result:</p> <pre><code>processes:\n  myprocess:\n    # ...\n    command: python otherapp.py\n</code></pre> <p>For the multi-value options <code>environment</code>, <code>depends_on</code>, <code>process-compose</code> merges entries together with locally-defined values taking precedence:</p> <p>original process:</p> <pre><code>processes:\n  myprocess:\n    # ...\n    environment:\n      - \"A=3\"\n      - \"C=8\"\n</code></pre> <p>local process:</p> <pre><code>processes:\n  myprocess:\n    # ...\n    environment:\n      - \"A=4\"\n      - \"B=5\"\n</code></pre> <p>result:</p> <pre><code>processes:\n  myprocess:\n    # ...\n    environment:\n      - \"A=4\"\n      - \"B=5\"\n      - \"C=8\"\n</code></pre>"},{"location":"tui/","title":"TUI (Terminal User Interface)","text":"<p>TUI Allows you to:</p> <ul> <li>Review processes status</li> <li>Start processes (only completed or disabled)</li> <li>Stop processes</li> <li>Review logs</li> <li>Restart running processes</li> </ul> <p>TUI is the default run mode, but it's possible to disable it:</p> <pre><code>./process-compose -t=false\n</code></pre> <p>Control the UI log buffer size:</p> <pre><code>log_level: info\nlog_length: 1200 #default: 1000\nprocesses:\n  process2:\n    command: \"ls -R /\"\n</code></pre> <p> Using a too large buffer will put more penalty on your CPU.</p> <p>By default <code>process-compose</code> uses the standard ANSI colors mode to display logs. However, you can disable it for each process:</p> <pre><code>processes:\n  process_name:\n    command: \"ls -R /\"\n    disable_ansi_colors: true #default false\n</code></pre> <p> Too long log lines (above 2^16 bytes long) can cause the log collector to hang.</p>"},{"location":"tui/#shortcuts-configuration","title":"Shortcuts Configuration","text":"<p>Default shortcuts can be changed by placing <code>shortcuts.yaml</code> in your <code>$XDG_CONFIG_HOME/process-compose/</code> directory. The default <code>process-compose</code> configuration is defined as:</p> <pre><code># $XDG_CONFIG_HOME/process-compose/shortcuts.yaml\nshortcuts:\n  log_follow: # action name - don't edit\n    toggle_description: # optional description for toggle buttons. Will use default if not defined\n      false: Follow Off\n      true: Follow On\n    shortcut: F5 # shortcut to be used\n  log_screen:\n    toggle_description:\n      false: Half Screen\n      true: Full Screen\n    shortcut: F4\n  log_wrap:\n    toggle_description:\n      false: Wrap Off\n      true: Wrap On\n    shortcut: F6\n  process_restart:\n    description: Restart # optional description for a button. Will use default if not defined\n    shortcut: Ctrl-R\n  process_screen:\n    toggle_description:\n      false: Half Screen\n      true: Full Screen\n    shortcut: F8\n  process_start:\n    description: Start\n    shortcut: F7\n  process_stop:\n    description: Stop\n    shortcut: F9\n  quit:\n    description: Quit\n    shortcut: F10\n</code></pre> <p><code>shortcuts.yaml</code> can contain only the values you wish to change, default values will be used for the rest. For example if you want to replace the default <code>quit</code> shortcut to be <code>F3</code> instead of <code>F10</code> and rename the <code>process_stop</code> to be <code>Terminate</code>, the configurion will be as follows: <pre><code># $XDG_CONFIG_HOME/process-compose/shortcuts.yaml\nshortcuts:\n  process_stop:\n    description: Terminate\n  quit:\n    shortcut: F3\n</code></pre></p>"},{"location":"tui/#tui-themes","title":"TUI Themes","text":"<p>The default shortcut for theme selection is <code>CTRL-T</code>. Process Compose comes with 4 pre-loaded themes.  These can be extended in 2 ways:</p> <ol> <li>By contributing a new theme, by creating a PR with a new theme in the <code>src/config/themes</code> directory.</li> <li>Adding your own theme by placing <code>theme.yaml</code> in your <code>$XDG_CONFIG_HOME/process-compose/</code> directory.</li> </ol> <p>The default <code>process-compose</code> theme is defined as:</p> <pre><code>style:\n  body:\n    fgColor: white\n    bgColor: black\n    secondaryTextColor: yellow\n    tertiaryTextColor: green\n    borderColor: white\n  stat_table:\n    keyFgColor: yellow\n    valueFgColor: white\n    logoColor: yellow\n  proc_table:\n    fgColor: lightskyblue\n    fgWarning: yellow\n    fgPending: grey\n    fgCompleted: lightgreen\n    fgError: red\n    headerFgColor: white\n  help:\n    fgColor: black\n    keyColor: white\n    hlColor: green\n    categoryFgColor: lightskyblue\n  dialog:\n    fgColor: cadetblue\n    bgColor: black\n    buttonFgColor: black\n    buttonBgColor: lightskyblue\n    buttonFocusFgColor: black\n    buttonFocusBgColor: dodgerblue\n    labelFgColor: yellow\n    fieldFgColor: black\n    fieldBgColor: lightskyblue\n</code></pre> <p><code>theme.yaml</code> can contain only the values you wish to change, default values will be used for the rest. For example if you want to change the default background color to <code>green</code> instead of <code>black</code> and the logo color to <code>blue</code>, the configuration will be as follows:</p> <pre><code>style:\n  body:\n    bgColor: green\n  stat_table:\n    logoColor: blue\n</code></pre> <p> To apply the new values it's enough to select the <code>Custom Style</code> (<code>F</code> shortcut) theme from the theme selector menu (<code>CTRL-T</code>).</p> <p>For Color names W3C approved color names should be used. Note that on various terminals colors may be approximated, or not supported at all.  If no suitable representation for a color is known, the no color will be set, deferring to whatever default attributes the terminal uses.</p> <p>By default <code>process-compose</code> will respect any theme used in your terminal which might result in less accurate color fidelity. To force the use of \"True Colors\", please use the <code>HEX</code> color notation:</p> <pre><code>style:\n  body:\n    bgColor: '#00FF00' #green\n  stat_table:\n    logoColor: '#0000FF' #blue\n</code></pre>"},{"location":"tui/#tui-state-settings","title":"TUI State Settings","text":"<p>TUI will automatically save its state when the after changing the following:</p> <ol> <li>TUI Theme</li> <li>Processes sort column</li> <li>Processes sort order (ascending / descending)</li> </ol> <p><code>settings.yaml</code> file location <code>$XDG_CONFIG_HOME/process-compose/</code></p>"},{"location":"tui/#settings-structure","title":"Settings Structure","text":"<pre><code>#XDG_CONFIG_HOME/process-compose/settings.yaml\n\ntheme: Cobalt\nsort:\n    by: NAME\n    isReversed: false\n</code></pre> <p> The auto save feature can be disabled by using the <code>--read-only</code> flag.</p>"}]}